---
title: "MEP LINCs Pilot QA Process"
author: "Mark Dane"
date: "`r Sys.Date()`"
output: pdf_document
---

##Summary
This report explains and demonstrates the QA process for MEP LINCs cell level data. The goals of the QA process are to identify any portions of the experiment that should be repeated and to exclude low quality data from the downstream analysis.

The QA process begins with the analysis of the DAPI-stained nucleii. These data are dependent on the number of cells that remained adhered to each spot at the time of imaging, the quality of the DAPI stain and staining process, the focus of the microscope during imaging and the effectiveness of the machine vision segmentation. 



```{r setup, echo=FALSE, message=FALSE}
library("ggplot2")
library("data.table")
library("MEMA")

numericMedian <- function(x) as.numeric(median(x))

calcQAScore <- function(DT, threshold, value){
  QAScore <- sum(DT[,value,with=FALSE] > threshold)/nrow(DT)
  return (QAScore)
}

evalMedians <- function(values, reps){
  tmp <- median(values[reps], na.rm=TRUE)
}


create8WellPseudoImage <- function(DT, pr, prDisplay){
  p <- ggplot(DT, aes_string(x="ArrayColumn", y="ArrayRow",colour=pr))+
    geom_point(size=1)+
    scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
    scale_colour_gradient(low = "white", high = "red",limits=quantile(DT[[pr]],probs = c(0,.998),na.rm=TRUE))+
    guides(colour = guide_legend(prDisplay, keywidth = .5, keyheight = .5))+
    ggtitle(paste(prDisplay,"for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
    xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=4)
}

create8WellHistograms <- function(DT, pr, prDisplay, binwidth = diff(quantile(DT[[pr]],probs = c(0,.98),na.rm=TRUE))/50, upperProb = .99, ncol = 4) {
  p <- ggplot(DT, aes_string(x=pr))+
    geom_histogram(binwidth = binwidth)+
    scale_x_continuous(limits = quantile(DT[[pr]],probs = c(0,upperProb),na.rm=TRUE))+
    ggtitle(paste(prDisplay,"in",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
    xlab(prDisplay)+
        theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=ncol)
}

 addMissingData <- function(DT, nrSpots){
    DTList <- lapply(unique(DT$Well), function(well){
      setkey(DT, Well)
      dt <- DT[well]
      #Create a datatable of a full array, then select only the rows for the missing spots
      missingSpots <- (1:nrSpots)[!(1:nrSpots %in% unique(dt$Spot))]
      if(!length(missingSpots)==0){
        missingData <- data.table(Well = well, Spot = missingSpots, LoessSCC=0, SpotCellCount = 0, QAScore = unique(dt$QAScore), key="Spot")
        dt <- rbind(dt, missingData, fill = TRUE)
      }
      return(dt)
    })
    return(rbindlist(DTList))
 }
 
#Revert back to the MEMA dataset when it has been updated
sDT <- fread("./SS2/Cell/Annotated Data/PC3_SS2_CellSpotAnn.txt")

barcodes <- sort(unique(sDT$Barcode))

#Set a threshold for the Loess QA
lthresh <- .6

#Pick a well for the explanation
explanationBarcode <- barcodes[1]
explanationWell <- unique(sDT$Well[sDT$Barcode == explanationBarcode])[6]

```
\newpage


##Quality Analysis
The variance of the signal in MEMA data comes from biological and technical factors. The technical factors create regions of low cell counts per spot and uneven staining across the array. The goal of the QA pipeline is to quantify the technical factors to identify wells or plates that need to be removed from downstream processing and/or be replaced by wells from a new experiment.

The hypothesis for the MEMA QA process is that the biological signal comes from individual spots while the technical variations come from regions of low signal. A bivariate loess model can be used to quantify the number of spots in low signal regions, leading to a MEMA QA score. 

###Loess Model Explanation
The loess model of a MEMA is the mean value of a weighted version of each spot's region or neighborhood. In a 700 spot array, a loess span value of 0.1 sets the size of the neighborhood to be the nearest 70 points (within approximately 5 spots in all directions). The weights are a tricubic function of the euclidean distance between the spot being modeled and the neighborhood spots. These weights vary from 1 to 0 as distances increase from the nearest to the farthest neighbor. In other words, each spot in the model takes on the mean value of its 70 nearest neighbors with the closest neighbors having the largest impact. Therefore, the loess model is dominated by the technical regional factors as opposed to individual biological responses.

A MEMA's QA score is derived from the loess model of the control-well-normalized values by calculating the proportion of spots in low signal regions(LSR). A threshold for classifying spots as LSR is based on the median of each plate's control well. To have higher scores reflect increasing quality, the MEMA QA score is defined as the proportion of non-LSR spots to total spots. This value will be 1 for MEMAs with no low signal regions and approach 0 as the number of LSR spots increases.

Below are plots showing data from well `r explanationWell` in plate `r explanationBarcode` which used LINCs staining set 2 (DAPI, fibrillarin, phalloidin, and EdU). The LSR spots are those to the left of the blue vertical line at the threshold value of `r lthresh ` in the histogram plus the spots without data values.


```{r SCC_PseudoImages , echo=FALSE, fig.width=2.5,fig.height=4}
DT <-sDT[sDT$Barcode==explanationBarcode & sDT$Well == explanationWell]


#Remove the fiducial entries
# setkey(DT,ShortName)
# DT <- DT[!"fiducial"]

p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=SpotCellCount))+
  geom_point(size=1.5)+
  scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
  scale_colour_gradient(low = "white", high = "red",limits=quantile(DT$SpotCellCount,probs = c(0,.998),na.rm=TRUE))+
  guides(colour = guide_legend("Spot Cell Count", keywidth = .5, keyheight = .5))+
  ggtitle(paste0("Spot Cell Count for ",unique(DT$CellLine), " cells\n in plate ",unique(DT$Barcode),", well ",explanationWell))+
  xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=LoessSCC))+
  geom_point(size=1.5)+
  scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
  scale_colour_gradient(low = "white", high = "red")+
  guides(colour = guide_legend("Loess Model of\nSpot Cell Count", keywidth = .5, keyheight = .5))+
  ggtitle(paste("Loess Model of Spot Cell Count for",unique(DT$CellLine), "cells\n in plate",unique(DT$Barcode),", well",explanationWell))+
  xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

#Add in a row for each missing spot and set the spot cell count to 0
nrSpots <- max(DT$ArrayRow)*max(DT$ArrayColumn)

DT <- addMissingData(DT, nrSpots)
explanationQAScore <- sprintf("%.2f",unique(DT$QAScore))
  
p <- ggplot(DT, aes(x=LoessSCC))+
  geom_histogram(binwidth=diff(quantile(DT$LoessSCC,probs = c(0,.98),na.rm=TRUE))/20)+
  geom_vline(xintercept=lthresh, colour="blue")+
  annotate("text", x = 1.5, y = 30, label = paste0("QA\n",explanationQAScore), colour="red", size=rel(5))+
  ggtitle(paste("Loess Model of Spot Cell Count for",unique(DT$CellLine), "cells\n in plate",unique(DT$Barcode),", well",explanationWell))+xlab("Spot Cell Count")+
  theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.8)), axis.title.x = element_text(size=rel(.5)),axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), axis.title.y = element_text(size=rel(.5)), plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))


```

\newpage

##QA Scoring of the dataset
```{r Heatmaps_QAScores, echo=FALSE, fig.width=3.7,fig.height=4, eval=TRUE}

for (barcode in barcodes){
  DT <-sDT[sDT$Barcode==barcode,]
  #Remove the fiducial entries
  setkey(DT,ShortName)
  DT <- DT[!"fiducial"]
  
  p <- create8WellPseudoImage(DT, pr = "SpotCellCount",prDisplay = "Spot Cell Count")
  suppressWarnings(print(p))
  
  p <- create8WellPseudoImage(DT, pr = "LoessSCC",prDisplay = "Loess Spot Cell Count")
  suppressWarnings(print(p))
  
  
  DT <- addMissingData(DT, nrSpots)
  p <- create8WellHistograms(DT,pr = "SpotCellCount", prDisplay = "Spot Cell Count")
  suppressWarnings(print(p))
  
  wellScores <- unique(DT[,list(Well, QAScore=sprintf("%.2f",QAScore))])
  
  p <- ggplot(DT, aes(x=LoessSCC))+
    geom_histogram(binwidth=diff(quantile(DT$LoessSCC,probs = c(0,.98),na.rm=TRUE))/20)+
    geom_vline(xintercept=lthresh, colour="blue")+
    geom_text(data=wellScores, aes(label=paste0("QA\n",QAScore)), x = 1.5, y = 40, size = rel(3), colour="red")+
    ggtitle(paste("QA on Loess Model of Spot Cell Count for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+xlab("Spot Cell Count")+xlim(0,3)+
    theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=4)
  suppressWarnings(print(p))
  
  cat(sprintf("Mean QA Score for %9s = %.2f \n",barcode,mean(DT$QAScore)))
  
}

```

\newpage

##Number of Replicates

The mostly random layout of the LINCs MEMA enables statistically valid analyses of subsections that include fewer replicates of each MEP type. The folowing sections use the CVs and the variance of the median to evaluate the replicate number.

```{r Replicate_Counts, echo=FALSE, fig.width = 8, fig.height=4, eval=TRUE}

rDT <- unique(sDT[,RepCount := .N, by="Barcode,Ligand,ShortName"][,list(Barcode,Well,Ligand,ShortName,RepCount)])
setkey(rDT,ShortName)
rDT <- rDT[!"blank"]
rDT <- rDT[!"fiducial"]
rDT <- rDT[!"NID1"]

table(rDT$RepCount)


p <- ggplot(rDT, aes(x=reorder(ShortName, RepCount, median), y = RepCount))+ geom_boxplot()+
  xlab("ECM Protein")+
     theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1,size = rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)),strip.text = element_text(size = rel(.5)))
 suppressWarnings(print(p))
 
 p <- ggplot(rDT, aes(x=reorder(Ligand, RepCount, median), y = RepCount))+ geom_boxplot()+
  xlab("Ligand")+
     theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1,size = rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)),strip.text = element_text(size = rel(.5)))
 suppressWarnings(print(p))

setkey(rDT,Barcode,Well) 
unique(rDT[rDT$RepCount<10])
unique(rDT[rDT$RepCount<5])
 
```

###CVs vs. Number of Replicates
This analysis shows the CVs of the CellMask signal as the number of MEP replicates increases from 3 to 13. The data is the median normalized CellMask responses from well B02 in plate LI8X00101. The results are from 100 runs, each calculating CVs on randomly choosen replicates of 3-13 MEP responses. The intention is to show the range of CVs to expect if not all of the array is used in the downstream analysis.

CVs for the higher variance replicates decrease as the number of replicates increases. There appears to be a convergence of the CV values around ten replicates.  

```{r Create_LI8X00101_CVS_vs_Replicates, echo=FALSE, fig.width = 8, fig.height=4, eval=FALSE}

DT <-popDT[popDT$Barcode=="LI8X00101" & popDT$Well == "B02"]
#Remove the fiducial entries
setkey(DT,ShortName)
DT <- DT[!"fiducial"]

evalCVs <- function(values, reps){
  tmp <- CV(values[reps])
}

permList <- lapply(1:100,function (x){
cvList <- lapply(3:min(table(DT$ShortName)), function(nrRep){
  repV <- sample(1:min(table(DT$ShortName)),size = nrRep,replace = FALSE)
  cvDT <- DT[,evalCVs(Net.532.MedNorm,repV),by="Well,ShortName"]
  setnames(cvDT, "V1", "CV")
  cvDT$Reps <- nrRep
  return(cvDT)
})
cvRepDT <-rbindlist(cvList)
})

cvPerms <- rbindlist(permList)

p <- ggplot(cvPerms[cvPerms$ShortName %in% c("LAMB1", "DSG2")], aes(x=factor(Reps),y=CV, colour = ShortName))+
  #geom_point(alpha=.02)+stat_smooth(method="gam", se=TRUE)+
  geom_boxplot()+
#       p <- ggplot(lfDT, aes(x=ShortName))+
#   geom_bar(width=.8)+geom_hline(yintercept = mean(table(lfDT$ShortName)), colour="blue")+
   ggtitle(" \n\nRange of CVs vs Increasing Number of Replicates")+
   xlab("Number of replicates")+ylab("CV")+
ylim(0,.4)+facet_wrap(~ShortName, ncol=4)+
  guides(colour=FALSE)+
   theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size = rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)),strip.text = element_text(size = rel(.5)))
 suppressWarnings(print(p))

```

```{r Plot LI8X00101_CVS_vs_Replicates, echo=FALSE, fig.width = 8, fig.height=11, eval=FALSE}

p <- ggplot(cvPerms, aes(x=factor(Reps),y=CV, colour = ShortName))+
  #geom_point(alpha=.02)+stat_smooth(method="gam", se=TRUE)+
  geom_boxplot()+
#       p <- ggplot(lfDT, aes(x=ShortName))+
#   geom_bar(width=.8)+geom_hline(yintercept = mean(table(lfDT$ShortName)), colour="blue")+
   ggtitle(" \n\nRange of CVs vs Increasing Number of Replicates")+
   xlab("Number of replicates")+ylab("CV")+
ylim(0,2)+facet_wrap(~ShortName, ncol=4)+
  guides(colour=FALSE)+
   theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size = rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)),strip.text = element_text(size = rel(.5)))
 suppressWarnings(print(p))

```

###Median vs. Number of Replicates
An alternative to CVs is to look for the variance in the median value. Similar to the CV method, the data is 100 random samplings from well B02 of plate LI8X00101. The variance is represented by the size of the boxplot. As the number of replicates increases the size of the boxes converges to the median. It appears that for the higher variance data, the boxplots are still converging at 13 replicates which provides evidence that the number of replicates whould remain as high as possible. 

```{r Create_LI8X00101_Median_vs_Replicates, echo=FALSE, fig.width = 8, fig.height=4, eval=FALSE}

DT <-popDT[popDT$Barcode=="LI8X00101" & popDT$Well == "B02"]
#Remove the fiducial entries
setkey(DT,ShortName)
DT <- DT[!"fiducial"]

permList <- lapply(1:100,function (x){
medList <- lapply(3:min(table(DT$ShortName)), function(nrRep){
  repV <- sample(1:min(table(DT$ShortName)),size = nrRep,replace = FALSE)
  medDT <- DT[,evalMedians(Net.532.MedNorm,repV),by="Well,ShortName"]
  setnames(medDT, "V1", "Median")
  medDT$Reps <- nrRep
  return(medDT)
})
medRepDT <-rbindlist(medList)
})

medPerms <- rbindlist(permList)

p <- ggplot(medPerms[medPerms$ShortName %in% c("LAMB1", "DSG2")], aes(x=factor(Reps),y=Median, colour = ShortName))+
  #geom_point(alpha=.02)+stat_smooth(method="gam", se=TRUE)+
  geom_boxplot()+
  ylim(.5,1)+
#       p <- ggplot(lfDT, aes(x=ShortName))+
#   geom_bar(width=.8)+geom_hline(yintercept = mean(table(lfDT$ShortName)), colour="blue")+
   ggtitle(" \n\nRange of Medians vs Increasing Number of Replicates")+
   xlab("Number of replicates")+ylab("Median")+
facet_wrap(~ShortName, ncol=4)+
  guides(colour=FALSE)+
   theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size = rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)),strip.text = element_text(size = rel(.5)))
 suppressWarnings(print(p))

```

```{r Plot LI8X00101_Median_vs_Replicates, echo=FALSE, fig.width = 8, fig.height=11, eval=FALSE}

DT <-popDT[popDT$Barcode=="LI8X00101" & popDT$Well == "B02"]
#Remove the fiducial entries
setkey(DT,ShortName)
DT <- DT[!"fiducial"]

permList <- lapply(1:100,function (x){
medList <- lapply(3:min(table(DT$ShortName)), function(nrRep){
  repV <- sample(1:min(table(DT$ShortName)),size = nrRep,replace = FALSE)
  medDT <- DT[,evalMedians(Net.532.MedNorm,repV),by="Well,ShortName"]
  setnames(medDT, "V1", "Median")
  medDT$Reps <- nrRep
  return(medDT)
})
medRepDT <-rbindlist(medList)
})

medPerms <- rbindlist(permList)
setkey(medPerms,ShortName)
#cvPerms <- cvPerms["ALCAM"]
p <- ggplot(medPerms, aes(x=factor(Reps),y=Median, colour = ShortName))+
  #geom_point(alpha=.02)+stat_smooth(method="gam", se=TRUE)+
  geom_boxplot()+
  ylim(.5,1)+
#       p <- ggplot(lfDT, aes(x=ShortName))+
#   geom_bar(width=.8)+geom_hline(yintercept = mean(table(lfDT$ShortName)), colour="blue")+
   ggtitle(" \n\nRange of Medians vs Increasing Number of Replicates")+
   xlab("Number of replicates")+ylab("Median")+
facet_wrap(~ShortName, ncol=4)+
  guides(colour=FALSE)+
   theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size = rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)),strip.text = element_text(size = rel(.5)))
 suppressWarnings(print(p))

```


\newpage
##Supplemental Material


The plates were printed with 35 row by 20 column MEMAs. Each sample spot contains one ECM protein paired with Collagen I. There are 46 different ECM proteins in the array arranged in a random fashion.

The spots that were not printed are labeled as blank.  


##MEMA Layout
The LINCs MEMA has 46 ECM proteins spotted in 35 rows and 20 columns using a 7x4 pin head that printed 5x5 blocks. The proteins are randomly assigned to the top 30 rows of spots. Rows 31-35 are replicates of rows 1-5. The upper left and bottom right corners are image fiducials in the 488nm channel and there are four blank spots for checking orientation in all channels.     

```{r Content Layout,echo=FALSE, message=FALSE, warnings=FALSE, fig.width=6}

#Select only one type of array to display and show the  pattern
DT <- popDT[,list(Block,Position,ShortName,Name,ID,ArrayRow,ArrayColumn),keyby=Well]
DT <- DT["A01",]
DT <- unique(DT,by=NULL)

p <- ggplot(DT,aes(x = ArrayColumn, y = ArrayRow, fill=ShortName))+
  geom_point(shape=21, size = 2.2)+
  #scale_colour_manual(values=c("black", "white"))+
  guides(fill=guide_legend(ncol = 4))+guides( colour = FALSE )+
  theme(legend.text = element_text(size = rel(.5)),legend.title=element_text(size = rel(.5)),plot.title=element_text(size = rel(.8))
        # , plot.margin = unit(c(2, 0.5, 1, 1), "in")
  )+
  scale_y_reverse()+
  xlab("")+ylab("")+
  ggtitle(" \n\nLINCs ECM A Row Layout")
print(p)

```

##Replicate Count
The LINCs MEMA has an average of 15 replicates with a range from 13 to 19.  

```{r Layout Replicate Count,echo=FALSE, message=FALSE, warnings=FALSE, fig.width=6.5, fig.height=3}
#Remove the fiducial entries
setkey(DT,ShortName)
DT <- DT[!"fiducial"]
p <- ggplot(DT, aes(x=ShortName))+
  geom_bar(width=.8)+geom_hline(yintercept = mean(table(DT$ShortName)), colour="blue")+
  ggtitle(" \n\nCount of Replicate ECM Proteins In LINCs MEMA")+
  xlab("Printed ECM Protein")+ylab("Number of spots")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)),axis.title.x = element_text(size=rel(.8)),axis.title.y = element_text(size=rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)))

print(p)

```
