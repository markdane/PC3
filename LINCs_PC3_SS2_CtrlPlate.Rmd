---
title: "LINCs MEP Pilot QA Pipeline"
author: "Mark Dane"
date: "`r Sys.Date()`"
output: pdf_document
---

##Summary
This experiment uses the LINCs cell cycle staining set on for the control plate of the PC3 cells. 

The plates were printed with 35 row by 20 column MEMAs using a 4x7 pin head that printed 5x5 blocks. Each sample spot contains one ECM protein paired with Collagen I. There are 46 different ECM proteins in the array arranged in a random fashion.

Images of each well were gathered on a Tecan LS Reloaded laser scanner and Olympus ScanR automated microscope. This staining set includes, DAPI, H3K9me3 (488nm), Fibrillarin(532 and 555) and EdU(635 and 647nm). Data from DAPI staining is only gathered by the ScanR. 

Tecan data is gathered at the spot population level by fitting round regions of interest (ROIs) to each spot. The Tecan data in this report uses the net values defined as the raw ROI value minus the mean of the local background.

The spots that were not printed are labeled as blank.  


```{r setup, echo=FALSE, message=FALSE}
library("ggplot2")
library("data.table")
library("MEMA")

numericMedian <- function(x) as.numeric(median(x))

calcQAScore <- function(DT, threshold, value){
  QAScore <- sum(DT[,value,with=FALSE] > threshold)/nrow(DT)
  return (QAScore)
}

evalMedians <- function(values, reps){
  tmp <- median(values[reps], na.rm=TRUE)
}

#Revert back to the MEMA dataset when it has been updated
#popDT <- MEMA::popDT
popDT <- fread("./Annotated Data/LI8X00109PopAnn.txt")

barcodes <- sort(unique(popDT$Barcode))

#Set a threshold for the Loess QA
lthresh <- .6

# Clean up the dataset that will be used in the analysis
popDT <- popDT[!popDT$ShortName =="blank"]
popDT$ShortName <- gsub("blank","",popDT$ShortName)
setnames(popDT,"Ligand","LigandAnnotID")
ms <- gregexpr("^[[:alnum:]]*[^_]", popDT$LigandAnnotID)
popDT$Ligand <- unlist(regmatches(popDT$LigandAnnotID, ms))

```

\newpage

##QA Scoring of the dataset

```{r Plot LI8X001_532_Show_QA, echo=FALSE, fig.width=3.7,fig.height=4}

for (barcode in unique(popDT$Barcode)){
  DT <-popDT[popDT$Barcode==barcode,]
  #Remove the fiducial entries
  setkey(DT,ShortName)
  DT <- DT[!"fiducial"]

  p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=Net.532))+
    geom_point(size=1)+
    scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
    scale_colour_gradient(low = "white", high = "red")+
    guides(colour = guide_legend(unique(DT$EndPoint555), keywidth = .5, keyheight = .5))+
    ggtitle(paste("Raw Data of Tecan",unique(DT$EndPoint555),"Signal\n for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
    xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=4)
  suppressWarnings(print(p))
  
  p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=Loess555))+
    geom_point(size=1)+
    scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
    scale_colour_gradient(low = "white", high = "red")+
    guides(colour = guide_legend(unique(DT$EndPoint555), keywidth = .5, keyheight = .5))+
    ggtitle(paste("Loess Model of Tecan",unique(DT$EndPoint555),"Signal\n for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
    xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=4)
  suppressWarnings(print(p))
  
  
  p <- ggplot(DT, aes(x=Net.532))+
    geom_histogram(binwidth=3000)+
    ggtitle(paste("Raw Tecan",unique(DT$EndPoint555)," Signal\n for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+xlab(unique(DT$EndPoint555))+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.5)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=4)
  suppressWarnings(print(p))
  
  
  DT <- DT[,QAScore := calcQAScore(.SD,threshold=lthresh,value="Loess555"),by="Well"]
  wellScores <- unique(DT[,list(Well,QAScore=sprintf("%.2f",QAScore))])

  p <- ggplot(DT, aes(x=Loess555))+
    geom_histogram(binwidth=.04)+
       facet_wrap(~Well, ncol=4)

r <- ggplot_build(p)

  textY <- .8*max(r$panel$ranges[[1]]$y.range)
    
    p <- ggplot(DT, aes(x=Loess555))+
    geom_histogram(binwidth=.04)+
      geom_text(data=wellScores, aes(label=paste0("QA\n",QAScore)), x = 1.25, y = textY, size = rel(3), colour="red")+
       facet_wrap(~Well, ncol=4)+
    geom_vline(xintercept=lthresh, colour="blue")+
    ggtitle(paste("Loess Model of Tecan",unique(DT$EndPoint555)," Signal\n for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+xlab(unique(DT$EndPoint555))+
    theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))

    suppressWarnings(print(p))
    
  cat(sprintf("Mean QA Score for %9s = %.2f \n",barcode,mean(DT$QAScore)))
  
}

```

\newpage

#Supplemental Material

##MEMA Layout
The LINCs MEMA has 46 ECM proteins spotted in 35 rows and 20 columns. The proteins are randomly assigned to the top 30 rows of spots. Rows 31-35 are replicates of rows 1-5. The upper left and bottom right corners are image fiducials in the 488nm channel and there are four blank spots for checking orientation in all channels.     

```{r Content Layout,echo=FALSE, message=FALSE, warnings=FALSE, fig.width=6}

#Select only one type of array to display and show the  pattern
DT <- popDT[,list(Block,Position,ShortName,Name,ID,ArrayRow,ArrayColumn),keyby=Well]
DT <- DT["A01",]
DT <- unique(DT,by=NULL)

p <- ggplot(DT,aes(x = ArrayColumn, y = ArrayRow, fill=ShortName))+
  geom_point(shape=21, size = 2.2)+
  #scale_colour_manual(values=c("black", "white"))+
  guides(fill=guide_legend(ncol = 4))+guides( colour = FALSE )+
  theme(legend.text = element_text(size = rel(.5)),legend.title=element_text(size = rel(.5)),plot.title=element_text(size = rel(.8))
        # , plot.margin = unit(c(2, 0.5, 1, 1), "in")
  )+
  scale_y_reverse()+
  xlab("")+ylab("")+
  ggtitle(" \n\nLINCs ECM A Row Layout")
print(p)

```

##Replicate Count
The LINCs MEMA has an average of 15 replicates with a range from 13 to 19.  

```{r Layout Replicate Count,echo=FALSE, message=FALSE, warnings=FALSE, fig.width=6.5, fig.height=3}
#Remove the fiducial entries
setkey(DT,ShortName)
DT <- DT[!"fiducial"]
p <- ggplot(DT, aes(x=ShortName))+
  geom_bar(width=.8)+geom_hline(yintercept = mean(table(DT$ShortName)), colour="blue")+
  ggtitle(" \n\nCount of Replicate ECM Proteins In LINCs MEMA")+
  xlab("Printed ECM Protein")+ylab("Number of spots")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=rel(.8)),axis.title.x = element_text(size=rel(.8)),axis.title.y = element_text(size=rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)))

print(p)

```

\newpage

##`r unique(popDT$EndPoint488) ` and `r unique(popDT$EndPoint647) ` Pseudoimages
```{r Plot LI8X001_488&647_Pseudoimages, echo=FALSE, fig.width=3.7,fig.height=4}

for (barcode in unique(popDT$Barcode)){
  DT <-popDT[popDT$Barcode==barcode,]
  #Remove the fiducial entries
  setkey(DT,ShortName)
  DT <- DT[!"fiducial"]

  p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=Net.488))+
    geom_point(size=1)+
    scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
    scale_colour_gradient(low = "white", high = "red")+
    guides(colour = guide_legend(unique(DT$EndPoint488), keywidth = .5, keyheight = .5))+
    ggtitle(paste("Raw Data of Tecan",unique(DT$EndPoint488),"Signal\n for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
    xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=4)
  suppressWarnings(print(p))
  
  p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=Loess488))+
    geom_point(size=1)+
    scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
    scale_colour_gradient(low = "white", high = "red")+
    guides(colour = guide_legend(unique(DT$EndPoint488), keywidth = .5, keyheight = .5))+
    ggtitle(paste("Loess Model of Tecan",unique(DT$EndPoint488),"Signal\n for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
    xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=4)
  suppressWarnings(print(p))
  
   p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=Net.635))+
    geom_point(size=1)+
    scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
    scale_colour_gradient(low = "white", high = "red")+
    guides(colour = guide_legend(unique(DT$EndPoint647), keywidth = .5, keyheight = .5))+
    ggtitle(paste("Raw Data of Tecan",unique(DT$EndPoint647),"Signal\n for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
    xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=4)
  suppressWarnings(print(p))
  
  p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=Loess647))+
    geom_point(size=1)+
    scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
    scale_colour_gradient(low = "white", high = "red")+
    guides(colour = guide_legend(unique(DT$EndPoint647), keywidth = .5, keyheight = .5))+
    ggtitle(paste("Loess Model of Tecan",unique(DT$EndPoint647),"Signal\n for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
    xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))+
    facet_wrap(~Well, ncol=4)
  suppressWarnings(print(p))
  
}

```

\newpage

##Quality Analysis
The variance of the signal in MEMA data comes from biological and technical factors. The technical factors create regions of low cell counts per spot and uneven staining across the array. The goal of the QA pipeline is to quantify the technical factors to identify wells or plates that need to be removed from downstream processing and/or be replaced by wells from a new experiment.

The hypothesis for the MEMA QA process is that the biological signal comes from individual spots while the technical variations come from regions of low signal. A bivariate loess model can be used to quantify the number of spots in low signal regions, leading to a MEMA QA score. 

###Loess Model Explanation
The loess model of a MEMA is the mean value of a weighted version of each spot's region or neighborhood. In a 700 spot array, a loess span value of 0.1 sets the size of the neighborhood to be the nearest 70 points (within approximately 5 spots in all directions). The weights are a tricubic function of the euclidean distance between the spot being modeled and the neighborhood spots. These weights vary from 1 to 0 as distances increase from the nearest to the farthest neighbor. In other words, each spot in the model takes on the mean value of its 70 nearest neighbors with the closest neighbors having the largest impact. Therefore, the loess model is dominated by the technical regional factors as opposed to individual biological responses.

A MEMA's QA score is derived from the loess model of the control-well-normalized values by calculating the proportion of spots in low signal regions(LSR). A threshold for classifying spots as LSR is based on the median of each plate's control well. To have higher scores reflect increasing quality, the MEMA QA score is defined as the proportion of non-LSR spots to total spots. This value will be 1 for MEMAs with no low signal regions and approach 0 as the number of LSR spots increases.

Below are plots showing data from well A02 from plate `r barcodes[1] ` from LINCs staining set 2 (DAPI, `r unique(popDT$EndPoint488) `,`r unique(popDT$EndPoint555) ` and `r unique(popDT$EndPoint647) `). The LSR spots are those to the left of the blue vertical line at the threshold value of `r lthresh ` in the histogram. 


```{r Plot LI8X001_532_heatmaps , echo=FALSE, fig.width=2.5,fig.height=4}
DT <-popDT[popDT$Barcode==barcodes[1] & popDT$Well == "A02"]
#Remove the fiducial entries
setkey(DT,ShortName)
DT <- DT[!"fiducial"]

p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=Net.532))+
  geom_point(size=1.8)+
  scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
  scale_colour_gradient(low = "white", high = "red")+
  guides(colour = guide_legend(unique(DT$EndPoint555), keywidth = .5, keyheight = .5))+
  ggtitle(paste("Raw Data of Tecan",unique(DT$EndPoint555),"Signal\n for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
  xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

p <- ggplot(DT, aes(x=ArrayColumn, y=ArrayRow,colour=Loess555))+
  geom_point(size=1.8)+
  scale_y_reverse()+   scale_x_continuous(breaks= c(min(DT$ArrayColumn),round(mean(c(min(DT$ArrayColumn),max(DT$ArrayColumn)))),max(DT$ArrayColumn)))+
  scale_colour_gradient(low = "white", high = "red")+
  guides(colour = guide_legend(unique(DT$EndPoint555), keywidth = .5, keyheight = .5))+
  ggtitle(paste("Loess Model of Tecan",unique(DT$EndPoint555),"Signal\n for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+
  xlab("")+ylab("")+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))

  DT <- DT[,QAScore := calcQAScore(.SD,threshold=lthresh,value="Loess555"),by="Well"]
  wellScores <- unique(DT[,list(Well,QAScore=sprintf("%.2f",QAScore))])

  p <- ggplot(DT, aes(x=Loess555))+
  geom_histogram(binwidth=.02)+
  geom_vline(xintercept=lthresh, colour="blue")+
  geom_text(data=wellScores, aes(label=paste0("QA\n",QAScore)), x = .9, y = 30, size = rel(7), colour="red")+
  ggtitle(paste("Loess Model of Tecan",unique(DT$EndPoint555)," Signal\n for",unique(DT$CellLine), "cells in plate",unique(DT$Barcode)))+xlab(unique(DT$EndPoint555))+
  theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(.5)), axis.text.y = element_text(angle = 0, vjust = 0.5, hjust=1, size=rel(1)), plot.title = element_text(size = rel(.5)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.3)))
suppressWarnings(print(p))


```

\newpage

##Number of Replicates

The mostly random layout of the LINCs MEMA enables statistically valid analyses of subsections that include fewer replicates of each MEP type. The folowing sections use the CVs and the variance of the median to evaluate the replicate number.

###CVs vs. Number of Replicates
This analysis shows the CVs of the `r unique(DT$EndPoint555) ` signal as the number of MEP replicates increases from 3 to 13. The data is the median normalized `r unique(DT$EndPoint555) ` responses from well B02 in plate `r barcodes[1] `. The results are from 100 runs, each calculating CVs on randomly choosen replicates of 3-13 MEP responses. The intention is to show the range of CVs to expect if not all of the array is used in the downstream analysis.

CVs for the higher variance replicates decrease as the number of replicates increases. There appears to be a convergence of the CV values around ten replicates.  

```{r Create_LI8X00110_CVS_vs_Replicates, echo=FALSE, fig.width = 8, fig.height=4}

DT <-popDT[popDT$Barcode==barcodes[1] & popDT$Well == "B02"]
#Remove the fiducial entries
setkey(DT,ShortName)
DT <- DT[!"fiducial"]

evalCVs <- function(values, reps){
  tmp <- CV(values[reps])
}

permList <- lapply(1:100,function (x){
cvList <- lapply(3:min(table(DT$ShortName)), function(nrRep){
  repV <- sample(1:min(table(DT$ShortName)),size = nrRep,replace = FALSE)
  cvDT <- DT[,evalCVs(Net.532.MedNorm,repV),by="Well,ShortName"]
  setnames(cvDT, "V1", "CV")
  cvDT$Reps <- nrRep
  return(cvDT)
})
cvRepDT <-rbindlist(cvList)
})

cvPerms <- rbindlist(permList)

p <- ggplot(cvPerms[cvPerms$ShortName %in% c("LAMB1", "DSG2")], aes(x=factor(Reps),y=CV, colour = ShortName))+
  #geom_point(alpha=.02)+stat_smooth(method="gam", se=TRUE)+
  geom_boxplot()+
#       p <- ggplot(lfDT, aes(x=ShortName))+
#   geom_bar(width=.8)+geom_hline(yintercept = mean(table(lfDT$ShortName)), colour="blue")+
   ggtitle(" \n\nRange of CVs vs Increasing Number of Replicates")+
   xlab("Number of replicates")+ylab("CV")+
ylim(0,.4)+facet_wrap(~ShortName, ncol=4)+
  guides(colour=FALSE)+
   theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size = rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)),strip.text = element_text(size = rel(.5)))
 suppressWarnings(print(p))

```

```{r Plot LI8X00110_CVS_vs_Replicates, echo=FALSE, fig.width = 8, fig.height=11}

p <- ggplot(cvPerms, aes(x=factor(Reps),y=CV, colour = ShortName))+
  #geom_point(alpha=.02)+stat_smooth(method="gam", se=TRUE)+
  geom_boxplot()+
#       p <- ggplot(lfDT, aes(x=ShortName))+
#   geom_bar(width=.8)+geom_hline(yintercept = mean(table(lfDT$ShortName)), colour="blue")+
   ggtitle(" \n\nRange of CVs vs Increasing Number of Replicates")+
   xlab("Number of replicates")+ylab("CV")+
ylim(0,2)+facet_wrap(~ShortName, ncol=4)+
  guides(colour=FALSE)+
   theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size = rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)),strip.text = element_text(size = rel(.5)))
 suppressWarnings(print(p))

```

###Median vs. Number of Replicates
An alternative to CVs is to look for the variance in the median value. Similar to the CV method, the data is 100 random samplings from well B02 of plate `r barcodes[1] `. The variance is represented by the size of the boxplot. As the number of replicates increases the size of the boxes converges to the median. It appears that for the higher variance data, the boxplots are still converging at 13 replicates which provides evidence that the number of replicates whould remain as high as possible. 

```{r Create_LI8X00110_Median_vs_Replicates, echo=FALSE, fig.width = 8, fig.height=4}

DT <-popDT[popDT$Barcode==barcodes[1] & popDT$Well == "B02"]
#Remove the fiducial entries
setkey(DT,ShortName)
DT <- DT[!"fiducial"]

permList <- lapply(1:100,function (x){
medList <- lapply(3:min(table(DT$ShortName)), function(nrRep){
  repV <- sample(1:min(table(DT$ShortName)),size = nrRep,replace = FALSE)
  medDT <- DT[,evalMedians(Net.532.MedNorm,repV),by="Well,ShortName"]
  setnames(medDT, "V1", "Median")
  medDT$Reps <- nrRep
  return(medDT)
})
medRepDT <-rbindlist(medList)
})

medPerms <- rbindlist(permList)

p <- ggplot(medPerms[medPerms$ShortName %in% c("LAMB1", "DSG2")], aes(x=factor(Reps),y=Median, colour = ShortName))+
  #geom_point(alpha=.02)+stat_smooth(method="gam", se=TRUE)+
  geom_boxplot()+
  ylim(.5,1)+
#       p <- ggplot(lfDT, aes(x=ShortName))+
#   geom_bar(width=.8)+geom_hline(yintercept = mean(table(lfDT$ShortName)), colour="blue")+
   ggtitle(" \n\nRange of Medians vs Increasing Number of Replicates")+
   xlab("Number of replicates")+ylab("Median")+
facet_wrap(~ShortName, ncol=4)+
  guides(colour=FALSE)+
   theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size = rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)),strip.text = element_text(size = rel(.5)))
 suppressWarnings(print(p))

```

```{r Plot LI8X00110_Median_vs_Replicates, echo=FALSE, fig.width = 8, fig.height=11}

DT <-popDT[popDT$Barcode==barcodes[1] & popDT$Well == "B02"]
#Remove the fiducial entries
setkey(DT,ShortName)
DT <- DT[!"fiducial"]

permList <- lapply(1:100,function (x){
medList <- lapply(3:min(table(DT$ShortName)), function(nrRep){
  repV <- sample(1:min(table(DT$ShortName)),size = nrRep,replace = FALSE)
  medDT <- DT[,evalMedians(Net.532.MedNorm,repV),by="Well,ShortName"]
  setnames(medDT, "V1", "Median")
  medDT$Reps <- nrRep
  return(medDT)
})
medRepDT <-rbindlist(medList)
})

medPerms <- rbindlist(permList)
setkey(medPerms,ShortName)
#cvPerms <- cvPerms["ALCAM"]
p <- ggplot(medPerms, aes(x=factor(Reps),y=Median, colour = ShortName))+
  #geom_point(alpha=.02)+stat_smooth(method="gam", se=TRUE)+
  geom_boxplot()+
  ylim(.5,1)+
#       p <- ggplot(lfDT, aes(x=ShortName))+
#   geom_bar(width=.8)+geom_hline(yintercept = mean(table(lfDT$ShortName)), colour="blue")+
   ggtitle(" \n\nRange of Medians vs Increasing Number of Replicates")+
   xlab("Number of replicates")+ylab("Median")+
facet_wrap(~ShortName, ncol=4)+
  guides(colour=FALSE)+
   theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size = rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)),strip.text = element_text(size = rel(.5)))
 suppressWarnings(print(p))

```

##Fiducial Carryover

The fiducials in the 1,1 and 35,20 spots consist of Alexa 488 flurophores conjugated to gelatin (maybe). This analysis compares the spots printed after the fiducials to their replicates, looking for evidence of carryover that could skew the data. The post-fiducial spots do not appear to be different from their replicates (a statistical test will be performed to validate this). 

The lower plot shows that the normalized median and distribution of the fiducials are significantly lower than the ECM proteins. This may be a problem for automated alignment with fiducials in this staining set.

```{r Fiducial_carryover, echo=FALSE, fig.width=8}

 #Create a status if this is a spot printed after a fiducial has been printed
 
#First, locate the spots printed after the fiducial printed by pin 28
popDT$PostFid <- (popDT$Block == 28 & popDT$Row == 1 & popDT$Column == 1 & popDT$Well %in% c("B01","A04")) | (popDT$Block == 1 & popDT$Row == 5 & popDT$Column == 4 & popDT$Well %in% c("B01","A04"))

 #Limit on only the ECMs that are post fiducial
 postFidECMs <- unique(popDT$ShortName[popDT$PostFid])
 p <- ggplot(popDT[popDT$ShortName %in% postFidECMs], aes(x=factor(Block), y=Net.488.MedNorm, colour=PostFid))+
   geom_boxplot(notch=TRUE)+
   ggtitle("Normalized 488 Signal of Post-Fiducial Spots")+
    ylab("Normalized 488 Intensity")+xlab("Print Block")+
     guides(colour=guide_legend("Post-Fiducial"))+
   facet_wrap(~ShortName)
  
 print(p)
 
  p <- ggplot(popDT, aes(x=ShortName, y=Net.488.MedNorm, colour=popDT$ShortName=="fiducial"))+
   geom_boxplot(notch=TRUE)+
    ggtitle("LINCs PC3 Staining Set 1 Normalized 488 Signal")+
    ylab("Normalized 488 Intensity")+xlab("ECM Protein")+
    guides(colour=guide_legend("Fiducial"))+
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1,size = rel(.8)),plot.title = element_text(size = rel(1)),legend.text=element_text(size = rel(.3)),legend.title=element_text(size = rel(.5)),strip.text = element_text(size = rel(.5)))
  
 print(p)
 
 
```