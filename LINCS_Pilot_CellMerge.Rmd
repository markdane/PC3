---
title: "Annotate Cell-Level MEP-LINCs Data"
author: "Mark Dane"
date: "`r Sys.Date()`"
output: pdf_document
---
##Summary
This script prepares cell-level data and metadata for the LINCs Analysis Pipeline. 

In the code, the variable ss determines which staining set (SS1, SS2 or SS3) to merge. All .txt data files in the ./Cell/Raw Data folder will be merged
with the well (xlsx) and log (XML) data from the ./Metadata folder.

This merging assumes that the actual, physical B row wells (B01-B04) have been printed upside-down. That is, rotated 180 degrees resulting in the spot 1,1 being in the lower right corner instead of the upper left corner. The metadata is matched to the actual printed orientation.

The data is filtered to remove objects with area less than 1000 pixels.

In addition to merging the metadata with the cell-level data, several types of derived parameters are added. These include:

Cell Density based on the number of nuclear centers within a radius around each nucleus.
Normalized intensity values calculated by dividing each intensity value by the median of the corresponding intensity value in the control well of the same plate. 

Some parameters are clustered or gated into two or more classifications. For example, cells are classified as EdU+ or EdU-, 2N and less or 4N and more DNA.
Each cell does not have every derived parameter as each staining set has unique endpoints.

The data is summarized by the median of the parameter at each spot. Then additional derived values are added to this spot-level dataset:

The Spot Cell Count for the number of cells at each spot
Loess models of the spot cell count that capture regional information about cell seeding.

The staining sets are summarized by the medians of their normalized replicate values then combined to the MEP-level within each cell line.


```{r setup, echo=FALSE, message=FALSE}
library("limma")
library("MEMA")
library("data.table")
library("parallel")
#library("grid")



 #Select a staining set
ss <- "SS2"
densityThresh <- 0.4
outerThresh <- 0.5

```


```{r Read and clean spotmetadata, echo=FALSE}

#Read in the spot metadata from the gal file
smd <- readSpotMetadata(paste0("./",ss,"/Metadata/20150515_LI8X001_v1.gal"))
#Relabel the column name to the ECMpAnnotID
setnames(smd, "Name", "ECMpAnnotID")

#Make a short name for display of ECMpAnnotID
#Remove the first underscore and all text after it
smd$ECMp <- gsub("_.*","",smd$ECMpAnnotID)
#Replace any dashes with the word blank
smd$ECMp <- gsub("-","blank",smd$ECMp)

#Add the print order and deposition number to the metadata
ldf <- readLogData(paste0("./",ss,"/Metadata/20150512-112336.xml"))
spotMetadata <- merge(smd,ldf, all=TRUE)
setkey(spotMetadata,Spot)
#Make a rotated version of the spot metadata to match the print orientation
spotMetadata180 <- rotateMetadata(spotMetadata)
ARowMetadata <- data.table(spotMetadata,Well=rep(c("A01", "A02","A03","A04"),each=nrow(spotMetadata)))
BRowMetadata <- data.table(spotMetadata180,Well=rep(c("B01", "B02","B03","B04"),each=nrow(spotMetadata180)))

```


```{r ScanR merge_normalize and QA, echo=FALSE}
#The next steps are to bring in the well metadata, the print order and the ScanR data

cellDataFiles <- dir(paste0(ss,"/Cell/Raw Data"),full.names = TRUE)
splits <- strsplit2(strsplit2(cellDataFiles,split = "_")[,1],"/")
barcodes <- unique(splits[,ncol(splits)])
expDTList <- lapply(barcodes, function(barcode){
  #browser()
  plateDataFiles <- grep(barcode,cellDataFiles,value = TRUE)
  wells <- unique(strsplit2(split = "_",plateDataFiles)[,2])
  wellDataList <- lapply(wells,function(well){
    #browser()
    wellDataFiles <- grep(well,plateDataFiles,value = TRUE)
    mainDataFile <- grep("main",wellDataFiles,value=TRUE,ignore.case = TRUE)
    cytoDataFile <- grep("Cyto",wellDataFiles,value=TRUE,ignore.case = TRUE)
    
    #Read in and merge the main and cyto data for each well
    mainDT <- convertColumnNames(fread(mainDataFile,stringsAsFactors=FALSE))
    #Add the stain location for each wavelength in the 'main' file
    waveLengths <- grep("Intensity",colnames(mainDT), value=TRUE)
    for(waveLength in waveLengths){
      mainDT <- mainDT[,paste0("Location",waveLength) := "Nucleus", with=FALSE]
    }
    
    if(length(cytoDataFile)) {
      cytoDT <- convertColumnNames(fread(cytoDataFile,stringsAsFactors=FALSE))
      #Add the stain location for each wavelength in the 'Cyto' file
      waveLengths <- grep("Intensity",colnames(cytoDT), value=TRUE)
      for(waveLength in waveLengths){
        cytoDT <- cytoDT[,paste0("Location",waveLength) := "Cytoplasm", with=FALSE]
      }
      #Merge the cyto data to the main data using  ParentObjectIDMO
      # in the cyto file and ObjectID in the main file
      setkey(mainDT,key="ObjectID")
      setkey(cytoDT,key="ParentObjectIDMO")
      DT <- mainDT[cytoDT]
    } else {
      DT <- mainDT
    }
    
    #clean up the column names
    deleteNames <- colnames(DT)[colnames(DT) %in% c("Position","ParentObjectIDWell","ParentTraceID","i.ObjectID","i.ParentTraceID", "i.Area")]
    DT <- DT[,deleteNames :=NULL, with = FALSE]
    
    setnames(DT,"Well","Spot")
    #Add the well name as a parameter
    DT$Well <- well
    #Merge the data with its metadata based on the row it's in
    m <- regexpr("[[:alpha:]]",well)
    row <- regmatches(well,m)
    setkey(DT,Spot)
    DT <- switch(row,A = merge(DT,spotMetadata,all=TRUE),B = merge(DT,spotMetadata180,all=TRUE))
    #Add the well name again to fill in NA values
    DT$Well <- well
    return(DT)
  })
  
  #Create the cell data.table with spot metadata for the plate 
  pcDT <- rbindlist(wellDataList, fill = TRUE)
  #browser()
  #Read the well metadata from a multi-sheet Excel file
  wellMetadata <- data.table(readMetadata(paste0(ss,"/Metadata/",barcode,".xlsx")), key="Well")
  #Create a ligand display name by removing the first underscore and all trailing text
  wellMetadata$Ligand <- gsub("_.*","",wellMetadata$LigandAnnotID)
  #merge well metadata with the data and spot metadata
  #browser()
  pcDT <- merge(pcDT,wellMetadata,by = "Well")
  pcDT <- pcDT[,Barcode := barcode]
  #Count the cells at each spot
  pcDT<-pcDT[,SpotCellCount := length(ObjectID),by="Barcode,Well,Spot"]
  
  #Add the loess model of the SpotCellCount on a per well basis
  pcDT <- pcDT[,LoessSCC := loessModel(.SD,value="SpotCellCount",span=.1), by="Barcode,Well"]
  
  #If there is a highSerum well in the plate, use it for normalization
  if(sum(pcDT$Ligand=="HighSerum")){
    intensityNames <- grep("^MeanIntensity|^TotalIntensity",colnames(pcDT), value=TRUE)
    for(intensityName in intensityNames){
      #Median normalize to the plate's control well for each channel's value
      pcDT <- pcDT[,paste0(intensityName,"MedNorm") := normWellsWithinPlate(.SD, value=intensityName, baseECM = ".*",baseGF = "HighSerum"), by="Barcode"]
    }
    
    pcDT <- pcDT[,SpotCellCountMedNorm := normWellsWithinPlate(.SD, value="SpotCellCount", baseECM = ".*",baseGF = "HighSerum"), by="Barcode"]
  }
  
  
  #Filter out debris based on nuclear area
  nuclearAreaThresh <- 1000
  pcDT <- pcDT[pcDT$Area >nuclearAreaThresh,]
  
  return(pcDT)
})

cDT <- rbindlist(expDTList, fill = TRUE)

```

```{r, echo=FALSE, message=FALSE, warnings=FALSE}

cDT$TotalIntensityDAPI <- cDT$Area*cDT$MeanIntensityDAPI

#Add the local cartesian and polar coordinates, Wedge, Density and classifications for Sparse, OuterCell and Perimeter
setkey(cDT,Barcode,Well,Spot,ObjectID)
cDT <- merge(cDT,setkey(positionParms(cDT),Barcode,Well,Spot,ObjectID))

#Add a spot level normalizations on the intensity values
cDT <- cDT[,MeanIntensityAlexa488SpotNorm := MeanIntensityAlexa488/median(MeanIntensityAlexa488, na.rm=TRUE), by="Barcode,Well,Spot"]
cDT <- cDT[,MeanIntensityAlexa555SpotNorm := MeanIntensityAlexa555/median(MeanIntensityAlexa555, na.rm=TRUE), by="Barcode,Well,Spot"]
cDT <- cDT[,MeanIntensityAlexa647SpotNorm := MeanIntensityAlexa647/median(MeanIntensityAlexa647, na.rm=TRUE), by="Barcode,Well,Spot"]

#Create staining set specific derived parameters
if(ss %in% c("SS1", "SS3")){
  
} else if (ss == "SS2"){
  
  cDT <- cDT[,EdUPositive := kmeansCluster(.SD, value="MeanIntensityAlexa647MedNorm", ctrlLigand = "HighSerum"), by="Barcode"]
  #Calculate the EdU Positive Percent at each spot
  cDT <- cDT[,EdUPositiveProportion := sum(EdUPositive)/length(ObjectID),by="Barcode,Well,Spot"]
} else stop("Invalid ss parameter")

#TODO: Debug the addition of EndpointDAPI

# Eliminate Variations in the Endpoint metadata
endpointNames <- grep("End",colnames(cDT), value=TRUE)
endpointWL <- regmatches(endpointNames,regexpr("[[:digit:]]{3}|DAPI",endpointNames))
setnames(cDT,endpointNames,paste0("Endpoint",endpointWL))

#Cell cycle on total DNA under developent and not implemented
# MclustCluster <- function(x){
#   #browser()
#   mod <- densityMclust(x,G=2, modelNames = "E")
#   return(mod[["classification"]])
# }
# 
# mixtoolCluster <- function(x){
#   browser()
#   histinfo <- hist(x,breaks=100)
#   
#   mod <- normalmixEM(x, sd.constr=c("a","a"))
#   return(mod[["classification"]])
# }
# 
# #Set 2N and 4N DNA status
# cDT <- cDT[,DNA4N := kmeansCluster(Total.Intensity.DAPI), by="Barcode,Well"]

```

```{r, echo=FALSE, message=FALSE, warnings=FALSE, eval=TRUE}

#Select the columns and order for saving in the cell-level annotated data file
coreLevel1DataColumns <- c("X","Y","Z","XLocal","YLocal","RadialPosition","Theta","TotalIntensityDAPI","MeanIntensityDAPI","MeanIntensityAlexa488","MeanIntensityAlexa555","MeanIntensityAlexa647","Area","ElongationFactor")

coreLevel2DataColumns<- c("X","Y","Z","XLocal","YLocal","RadialPosition","Theta","SpotCellCount","LoessSCC","MeanIntensityDAPIMedNorm","MeanIntensityAlexa488MedNorm","MeanIntensityAlexa555MedNorm","MeanIntensityAlexa647MedNorm","SpotCellCountMedNorm","MeanIntensityAlexa488SpotNorm","MeanIntensityAlexa555SpotNorm","MeanIntensityAlexa647SpotNorm","Density","Wedge","Sparse","OuterCell","Perimeter")

coreMetadataColumns <- c("Barcode","Well","Spot","ArrayRow","ArrayColumn","Block","Row","Column","ObjectID","LocationMeanIntensityDAPI","LocationMeanIntensityAlexa488","LocationMeanIntensityAlexa555","LocationMeanIntensityAlexa647","CellLine","EndpointDAPI","Endpoint488","Endpoint555","Endpoint647","LigandAnnotID","Ligand","ECMpAnnotID","ECMp","PrintOrder")


if (ss == "SS1") {
  cDTLevel1 <- cDT[,c(coreMetadataColumns, coreLevel1DataColumns), with=FALSE]
  cDTLevel2 <- cDT[,c(coreMetadataColumns, coreLevel2DataColumns), with=FALSE]
  
} else if(ss=="SS2"){
  cDTLevel1 <- cDT[,c(coreMetadataColumns, coreLevel1DataColumns), with=FALSE]
  cDTLevel2 <- cDT[,c(coreMetadataColumns, coreLevel2DataColumns,"EdUPositive"), with=FALSE]
  
}
write.table(cDTLevel1, paste0(ss,"/Cell/Annotated Data/",unique(cDT$CellLine),"_",ss,"_","Level1.txt"), sep = "\t",row.names = FALSE, quote=FALSE)
write.table(cDTLevel2, paste0(ss,"/Cell/Annotated Data/",unique(cDT$CellLine),"_",ss,"_","Level2.txt"), sep = "\t",row.names = FALSE, quote=FALSE)

```

```{r SpotLevelData, echo=FALSE}

#Summarize cell data to spot level (sl) by taking the medians of the parameters
parameterNames<-grep(pattern="(^Total|^Mean|Elongation|Area|SpotCellCount|EdUPositiveProportion|RadialPosition|Population|Loess|Density|Z|Barcode|^Spot$|^Well$)",x=names(cDT),value=TRUE)

#Remove any spot-normalized parameters
parameterNames <- grep("SpotNorm",parameterNames,value=TRUE,invert=TRUE)

cDTParameters<-cDT[,parameterNames,with=FALSE]
slDT<-cDTParameters[,lapply(.SD,numericMedian),keyby="Barcode,Well,Spot"]

#Merge back in the spot and well metadata
metadataNames <- grep("(Row|Column|PrintOrder|Block|^ID$|Array|CellLine|Ligand|Endpoint|ECMp|Location|Barcode|^Well$|^Spot$)", x=colnames(cDT), value=TRUE)
mDT <- cDT[,metadataNames,keyby="Barcode,Well,Spot", with=FALSE]
slDT <- mDT[slDT, mult="first"]

#Calculate CVs for each set of replicates in the ScanR data
cvNames<-grep(pattern="(^Total|^Mean|Elongation|Area|SpotCellCount|EdUPositiveProportion|RadialPosition|Population|Loess|Density|Z|Barcode|^Well$|ECMpAnnotID)",x=colnames(slDT),value=TRUE)
cvParameters<-slDT[,cvNames,with=FALSE]
cv<-cvParameters[,lapply(.SD,CV),by="Barcode,Well,ECMpAnnotID"]
data.table::setnames(cv,colnames(cv), paste0("CV",colnames(cv)))
data.table::setkey(cv,CVWell,CVECMpAnnotID, CVBarcode)
data.table::setkey(slDT,Well,ECMpAnnotID,Barcode)
slDT <- slDT[cv]

#Add well level QA Scores
lthresh <- 0.6
  slDT <- slDT[,QAScore := calcQAScore(.SD,threshold=lthresh,maxNrSpot = max(cDT$ArrayRow)*max(cDT$ArrayColumn),value="LoessSCC"),by="Barcode,Well"]

```

```{r, echo=FALSE, eval=TRUE}
  
write.table(slDT, paste0(ss,"/Cell/Annotated Data/",unique(slDT$CellLine),"_",ss,"_","Level3.txt"), sep = "\t",row.names = FALSE, quote=FALSE)

```

```{r MEPLevelData, echo=FALSE}
  
  
  #Summarize spot level data to MEP level by taking the medians of the parameters
  mepNames<-grep(pattern="(^Total|^Mean|Elongation|^Area|Z|^SpotCellCount|Loess|RadialPosition|EdUPositiveProportion|Population|Density|LigandAnnotID|ECMpAnnotID)",x=names(slDT),value=TRUE)
  
  mepKeep<-slDT[,mepNames,with=FALSE]
  mepDT<-mepKeep[,lapply(.SD,numericMedian),keyby="LigandAnnotID,ECMpAnnotID"]
  
  #Merge back in the replicate metadata
  mDT <- slDT[,list(Well,CellLine,Ligand,Endpoint488,Endpoint555,Endpoint647,EndpointDAPI,ECMp),keyby="LigandAnnotID,ECMpAnnotID"]
  mepDT <- mDT[mepDT, mult="first"]
  
```

```{r, echo=FALSE, eval=TRUE}
  
write.table(mepDT, paste0(ss,"/Cell/Annotated Data/",unique(slDT$CellLine),"_",ss,"_","Level4.txt"), sep = "\t",row.names = FALSE, quote=FALSE)

```
